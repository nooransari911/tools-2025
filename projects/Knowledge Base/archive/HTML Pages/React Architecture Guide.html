<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Architectural Guide</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Custom Font and Inline Tailwind Configuration -->
    <style>
        /* Import Google Font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        /* Set base font */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom scrollbar for a modern look */
        ::-webkit-scrollbar {
            width: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #000;
        }
        ::-webkit-scrollbar-thumb {
            background: rgb(60, 60, 60); /* Maintained as requested */
            border-radius: 5px;
            border: 2px solid #000;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #67e8f9; /* cyan-300 */
        }
    </style>
    <script>
        // Configure Tailwind to recognize our custom crimson color
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        crimson: 'rgb(255, 0, 80)',
                    }
                }
            }
        }
    </script>
</head>

<body class="bg-black text-gray-300 antialiased">

    <!-- Header Section -->
    <header class="text-center border-b border-gray-800 pb-8 pt-10 px-4">
        <h1 class="text-4xl md:text-5xl font-bold text-white mb-3">The Principles of Intentional Composition &amp; Extraction</h1>
        <p class="text-lg text-cyan-400">An Architectural Guide for React</p>
        <p class="text-gray-500 mt-4 text-sm">Location: Pune, Maharashtra, India | Time: <span id="time-display"></span></p>
    </header>

    <!-- Main Content Area -->
    <main class="container max-w-4xl mx-auto px-4 py-10">

        <!-- Core Doctrine Section -->
        <section class="mb-12">
            <h2 class="text-2xl font-semibold text-white mb-4">Core Doctrine</h2>
            <p class="text-gray-400 leading-relaxed">
                This guide establishes a disciplined methodology for developing React components. Its purpose is to ensure our codebase remains readable, scalable, and maintainable over the long term. We operate on the principle that the structure of our code is not a stylistic choice, but a deliberate architectural decision that directly impacts clarity, testability, and the cost of future development. This document outlines a hierarchy of rules, from the physical composition of the view to the logical extraction of its behavior. Adherence to these principles is not optional; it is fundamental to building a professional-grade application.
            </p>
        </section>

        <hr class="border-gray-800 my-12">

        <!-- Rule 1: Active Composition -->
        <section class="mb-12" id="rule-1">
            <h2 class="text-3xl font-bold text-cyan-400 mb-6">Rule #1: The Principle of Active Composition</h2>
            <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">The Rule</h3>
                    <p>The <code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">return</code> statement of a component must not contain a large, monolithic block of JSX. Instead, the view must be actively composed from smaller, logically-grouped JSX fragments assigned to clearly named constants within the component body. The final <code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">return</code> statement should deliver a single variable representing the fully assembled view.</p>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">The Guiding Philosophy</h3>
                    <p>A component's function body should be treated as a composition area, not just a render function. This is where the UI is thoughtfully assembled, piece by piece, from well-defined parts. The <code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">return</code> statement is merely the final step: delivering the finished product. This approach forces a developer to think about the structure of their UI upfront, breaking it down into its constituent parts before writing the code.</p>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">Code in Practice</h3>
                    <div class="mt-4 p-6 bg-gray-900 border border-crimson rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-crimson mb-3">ðŸ”´ Anti-Pattern: Monolithic Return</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>function UserDashboard({ user, stats, activity, notifications }) {
  // All structure is inlined, creating a confusing and fragile block.
  return (
    &lt;div className="dashboard-wrapper"&gt;
      &lt;header className="main-header"&gt;
        &lt;h1&gt;Welcome back, {user.name}&lt;/h1&gt;
        {notifications.length > 0 && &lt;NotificationBadge count={notifications.length} /&gt;}
      &lt;/header&gt;
      &lt;main className="dashboard-content"&gt;
        &lt;div className="stats-grid"&gt;
          {/* ...complex mapping and rendering of stats is inlined here... */}
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>
                    <div class="mt-6 p-6 bg-gray-900 border border-cyan-400 rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-cyan-400 mb-3">ðŸŸ¢ Best Practice: Composed View</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>function UserDashboard({ user, stats, activity, notifications }) {
  // Each logical section is an isolated, readable fragment.
  const dashboardHeader = (
    &lt;header className="main-header"&gt;
      &lt;h1&gt;Welcome back, {user.name}&lt;/h1&gt;
      {notifications.length > 0 && &lt;NotificationBadge count={notifications.length} /&gt;}
    &lt;/header&gt;
  );

  const statsDisplay = (&lt;div className="stats-grid"&gt;{/* ... */} &lt;/div&gt;);

  // The final view is assembled from clear, named parts.
  const dashboardView = (
    &lt;div className="dashboard-wrapper"&gt;
      {dashboardHeader}
      &lt;main className="dashboard-content"&gt;
        {statsDisplay}
      &lt;/main&gt;
    &lt;/div&gt;
  );

  // The return is simple, predictable, and clean.
  return dashboardView;
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <hr class="border-gray-800 my-12">

        <!-- Rule 2: Immediate Clarity -->
        <section class="mb-12" id="rule-2">
            <h2 class="text-3xl font-bold text-cyan-400 mb-6">Rule #2: The Rule of Immediate Clarity</h2>
            <div class="space-y-6">
                 <div>
                    <h3 class="text-xl font-semibold text-white mb-2">The Rule</h3>
                    <p>A function body may be written inline within a JSX prop (<code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">onClick</code>, <code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">onChange</code>) if and only if it consists of a single, declarative statement whose purpose is immediately obvious.</p>
                </div>
                 <div>
                    <h3 class="text-xl font-semibold text-white mb-2">Code in Practice</h3>
                     <div class="mt-4 p-6 bg-gray-900 border border-crimson rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-crimson mb-3">ðŸ”´ Anti-Pattern: Complex Inline Logic</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>&lt;Button onClick={() => {
  const payload = { id: item.id, timestamp: Date.now() };
  trackEvent('item_deleted', payload);
  api.delete(payload).then(() => refetch());
}} /&gt;</code></pre>
                    </div>
                    <div class="mt-6 p-6 bg-gray-900 border border-cyan-400 rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-cyan-400 mb-3">ðŸŸ¢ Best Practice: Simple Inline Delegation</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>&lt;Button onClick={() => handleDelete(item.id)} /&gt;
&lt;input onChange={(e) => setValue(e.target.value)} /&gt;</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <hr class="border-gray-800 my-12">

        <!-- Rule 3: Encapsulation Mandate -->
        <section class="mb-12" id="rule-3">
             <h2 class="text-3xl font-bold text-cyan-400 mb-6">Rule #3: The Encapsulation Mandate</h2>
             <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">The Rule</h3>
                    <p>If a function's logic is inherently tied to a single component's internal state and props, it must be defined as a named arrow function (<code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">const handleAction = () => {}</code>) inside that component's body.</p>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">The Guiding Philosophy</h3>
                    <p>This rule enforces the critical software design principle of <strong>encapsulation</strong>. A React component should be a self-contained system with private state and a public interface (props). The logic that operates on this private state must also be kept private, or co-located, within the component. This creates <strong>high cohesion</strong>, a state where a component's internal state and the logic that manipulates it are tightly and logically bound together.</p>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">Code in Practice</h3>
                    <div class="mt-4 p-6 bg-gray-900 border border-crimson rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-crimson mb-3">ðŸ”´ Anti-Pattern: Leaky Helper Function</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>// This external function is fragile and breaks encapsulation.
function handleLogin(event, email, pass, setStatus, setErrors) {
  event.preventDefault();
  setStatus('submitting');
  // ... logic ...
  if (/* success */) {
    setStatus('success');
  } else {
    setErrors(['Invalid credentials']);
    setStatus('error');
  }
}

function LoginForm() {
  const [email, setEmail] = useState('');
  const [pass, setPass] = useState('');
  const [status, setStatus] = useState('idle');
  const [errors, setErrors] = useState(null);

  // The component exposes all its internal state mechanisms.
  return (
    &lt;form onSubmit={e => handleLogin(e, email, pass, setStatus, setErrors)}&gt;
      {/* ... form inputs ... */}
    &lt;/form&gt;
  );
}</code></pre>
                    </div>
                    <div class="mt-6 p-6 bg-gray-900 border border-cyan-400 rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-cyan-400 mb-3">ðŸŸ¢ Best Practice: Encapsulated Handler</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>function LoginForm() {
  const [email, setEmail] = useState('');
  const [pass, setPass] = useState('');
  const [status, setStatus] = useState('idle');
  const [errors, setErrors] = useState(null);

  // The handler is a private method with natural access to state.
  const handleLogin = (event) => {
    event.preventDefault();
    setStatus('submitting');
    // ... logic ...
    if (/* success */) {
      setStatus('success');
    } else {
      setErrors(['Invalid credentials']);
      setStatus('error');
    }
  };

  return (
    &lt;form onSubmit={handleLogin}&gt;
      {/* ... form inputs ... */}
    &lt;/form&gt;
  );
}</code></pre>
                    </div>
                </div>
             </div>
        </section>

        <hr class="border-gray-800 my-12">

        <!-- Rule 4: Utility Drawer -->
        <section class="mb-12" id="rule-4">
             <h2 class="text-3xl font-bold text-cyan-400 mb-6">Rule #4: The Utility Drawer Principle</h2>
             <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">The Rule</h3>
                    <p>If a function is <strong>pure</strong> (its output depends only on its inputs) and its logic is generic, it must be extracted into a dedicated utility file (e.g., <code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">/utils/formatters.js</code>). These must be exported as standard named functions.</p>
                </div>
                 <div>
                    <h3 class="text-xl font-semibold text-white mb-2">Code in Practice</h3>
                     <div class="mt-4 p-6 bg-gray-900 border border-crimson rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-crimson mb-3">ðŸ”´ Anti-Pattern: Trapped Utility Function</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>function UserProfile({ user }) {
  // This is a perfect utility function, but it's locked away here.
  const isValidEmail = (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

  return &lt;div&gt;{isValidEmail(user.email) ? 'Valid Email' : 'Invalid Email'}&lt;/div&gt;;
}</code></pre>
                    </div>
                    <div class="mt-6 p-6 bg-gray-900 border border-cyan-400 rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-cyan-400 mb-3">ðŸŸ¢ Best Practice: Externalized Pure Function</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>// in /utils/validators.js
export function isValidEmail(email) {
  if (!email) return false;
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

// in /components/UserProfile.jsx
import { isValidEmail } from '../utils/validators';

function UserProfile({ user }) {
  return &lt;div&gt;{isValidEmail(user.email) ? 'Valid Email' : 'Invalid Email'}&lt;/div&gt;;
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <hr class="border-gray-800 my-12">

        <!-- Rule 5: Logic Service Extraction -->
        <section class="mb-12" id="rule-5">
            <h2 class="text-3xl font-bold text-cyan-400 mb-6">Rule #5: The Logic-View Decoupling Mandate</h2>
             <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">The Rule</h3>
                    <p>Components are strictly and purely view entities. All application state, business logic, side effects, and behavioral control must be encapsulated within explicit, external, named custom hooks. A component's role is to consume one or more hooks and use the state they provide to compose a view, preferably using the "Active Composition" pattern (Rule #1).</p>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">The Guiding Philosophy</h3>
                    <p>This is the most critical principle in our architecture. Its purpose is to enforce the absolute separation of two fundamentally different concerns: <strong>logic</strong> (what the application does) and <strong>view</strong> (what the application looks like). The primary motivation is not merely to enable reusability. The fundamental problem this rule solves is the destructive <strong>coupling of logic and view.</strong></p>
                    <p class="mt-4">When state management (<code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">useState</code>), side effects (<code class="bg-gray-800 text-crimson px-1.5 py-0.5 rounded-md text-sm">useEffect</code>), and behavioral handlers are intertwined within the same function body as the JSX view, they fuse into a monolithic entity. This monolith obscures all concerns simultaneously. To understand the view's structure, you must first mentally parse the complex web of state and effects. To understand the application's logic, you must hold the entire, often convoluted, JSX tree in your head. It becomes impossible to reason about either part in isolation.</p>
                    <p class="mt-4">By extracting all non-view concerns into a hook, we create two distinct, decoupled, and independently verifiable units. The hook is the "engine"â€”a pure behavioral controller that can be unit-tested in isolation. The component becomes the "chassis"â€”a pure view entity that can be visually tested in a tool like Storybook. This clean separation is the non-negotiable foundation of a scalable and professional React architecture.</p>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-white mb-2">Code in Practice</h3>
                    <div class="mt-4 p-6 bg-gray-900 border border-crimson rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-crimson mb-3">ðŸ”´ Anti-Pattern: "God Component"</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>function ProductDataGrid({ categoryId }) {
  // State, effects, and handlers are all fused with the view.
  const [products, setProducts] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [sortConfig, setSortConfig] = useState({ key: 'price', direction: 'ascending' });

  useEffect(() => {
    setIsLoading(true);
    fetchProductsAPI({ categoryId, sortBy: sortConfig.key, direction: sortConfig.direction })
      .then(setProducts)
      .catch(setError)
      .finally(() => setIsLoading(false));
  }, [categoryId, sortConfig]);

  const handleSort = (key) => { /* ...sorting logic... */ };

  if (error) return &lt;ErrorMessage message={error.message} /&gt;;

  return (
    &lt;div&gt;
      &lt;div className="grid-header"&gt;
        &lt;button onClick={() => handleSort('name')}&gt;Sort by Name&lt;/button&gt;
        &lt;button onClick={() => handleSort('price')}&gt;Sort by Price&lt;/button&gt;
      &lt;/div&gt;
      {isLoading ? &lt;Spinner /&gt; : &lt;table&gt;{/* ...rendering... */}&lt;/table&gt;}
    &lt;/div&gt;
  );
}</code></pre>
                    </div>
                    <div class="mt-6 p-6 bg-gray-900 border border-cyan-400 rounded-lg shadow-md">
                        <h4 class="text-lg font-semibold text-cyan-400 mb-3">ðŸŸ¢ Best Practice: Decoupled Logic and View</h4>
                        <pre class="overflow-x-auto text-sm text-gray-400 p-4 bg-black rounded-md"><code>// in /hooks/useSortedProducts.js
// The "engine": Contains ALL logic and state. Can be unit-tested in isolation.
export function useSortedProducts(categoryId) {
  const [products, setProducts] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [sortConfig, setSortConfig] = useState({ key: 'price', direction: 'ascending' });

  useEffect(() => {
    // ... all fetching and state logic is encapsulated here ...
  }, [categoryId, sortConfig]);

  const handleSort = (key) => { /* ... */ };

  // The hook provides a clean API.
  return { products, isLoading, error, sortConfig, handleSort };
}

// in /components/ProductDataGrid.jsx
// The "chassis": A PURE VIEW ENTITY.
import { useSortedProducts } from '../hooks/useSortedProducts';

function ProductDataGrid({ categoryId }) {
  // 1. Consume the logic engine.
  const { products, isLoading, error, sortConfig, handleSort } = useSortedProducts(categoryId);

  // 2. Compose the view from logical parts (Rule #1).
  const header = &lt;GridHeader onSort={handleSort} currentSort={sortConfig} /&gt;;

  const body = () => {
    if (isLoading) return &lt;Spinner /&gt;;
    if (error) return &lt;ErrorMessage message={error.message} /&gt;;
    return &lt;ProductTable products={products} /&gt;;
  };

  const dataGridView = (
    &lt;div&gt;
      {header}
      {body()}
    &lt;/div&gt;
  );

  // 3. Return the final composed view.
  return dataGridView;
}</code></pre>
                    </div>
                </div>
             </div>
        </section>

        <hr class="border-gray-800 my-12">

        <!-- Decision Flowchart -->
        <section class="mb-12" id="flowchart">
            <h2 class="text-3xl font-bold text-cyan-400 mb-6">Decision Flowchart</h2>
            <div class="bg-gray-900 border border-gray-700 rounded-lg p-6">
                <p class="mb-4">When developing a component, follow this hierarchy:</p>
                <ol class="list-decimal list-inside space-y-4 text-gray-300">
                    <li>
                        <strong class="text-white">Structure the View:</strong> How will the UI be composed?
                        <ul class="list-disc list-inside pl-6 mt-2 space-y-2 text-gray-400">
                            <li>Break the JSX into logical, named constants. The <code class="bg-gray-800 text-crimson px-1 py-0.5 rounded-md text-xs">return</code> statement must be a single variable. (<strong class="text-white">Rule #1</strong>)</li>
                        </ul>
                    </li>
                    <li>
                        <strong class="text-white">Place the Logic:</strong> For any given function or piece of logic, ask:
                        <ul class="list-disc list-inside pl-6 mt-2 space-y-2 text-gray-400">
                            <li>Is it a single, simple delegation/state update?
                                <ul class="list-circle list-inside pl-6 text-gray-500">
                                    <li><strong class="text-green-400">Yes:</strong> Keep it inline in the JSX. (<strong class="text-white">Rule #2</strong>)</li>
                                    <li><strong class="text-red-400">No:</strong> Continue to next question.</li>
                                </ul>
                            </li>
                            <li>Is the logic pure and generic?
                                <ul class="list-circle list-inside pl-6 text-gray-500">
                                    <li><strong class="text-green-400">Yes:</strong> Extract to a <code class="bg-gray-800 text-crimson px-1 py-0.5 rounded-md text-xs">/utils</code> file. (<strong class="text-white">Rule #4</strong>)</li>
                                    <li><strong class="text-red-400">No:</strong> Continue to next question.</li>
                                </ul>
                            </li>
                             <li>Is it complex, stateful logic involving multiple hooks?
                                <ul class="list-circle list-inside pl-6 text-gray-500">
                                    <li><strong class="text-green-400">Yes:</strong> Extract to a custom <code class="bg-gray-800 text-crimson px-1 py-0.5 rounded-md text-xs">/hooks</code> file. (<strong class="text-white">Rule #5</strong>)</li>
                                    <li><strong class="text-red-400">No:</strong> It is a component-specific handler. Define it with <code class="bg-gray-800 text-crimson px-1 py-0.5 rounded-md text-xs">const</code> inside the component. (<strong class="text-white">Rule #3</strong>)</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>
        </section>

    </main>
    <script>
        // Simple script to update the time dynamically
        function updateTime() {
            const timeElement = document.getElementById('time-display');
            if (timeElement) {
                const now = new Date();
                const options = {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: 'numeric',
                    timeZone: 'Asia/Kolkata',
                    hour12: true,
                    timeZoneName: 'short'
                };
                timeElement.textContent = new Intl.DateTimeFormat('en-US', options).format(now);
            }
        }
        // Set initial time based on provided context, then start interval
        const timeElement = document.getElementById('time-display');
        if(timeElement) {
            timeElement.textContent = "Saturday, August 9, 2025, 3:14 PM IST";
        }
        setInterval(updateTime, 60000); // Update every minute
    </script>
</body>
</html>
