{
  "structured_list": [
    {
      "file": "./AI_doc_processor_webapp/frontend/src/App.js",
      "content": "import React, { useState, useEffect, useCallback } from 'react';\nimport { fetchSchemas, processDocument } from './services/api'; // Import API functions\nimport OutputDisplay from './components/OutputDisplay'; // Import display component\nimport './index.css'; // Import global styles\n\nfunction App() {\n\t// State variables\n\tconst [file, setFile] = useState(null);\n\tconst [prompt, setPrompt] = useState('');\n\tconst [schemas, setSchemas] = useState([]); // List of available schema names\n\tconst [selectedSchema, setSelectedSchema] = useState(''); // Currently selected schema\n\tconst [selectedModel, setSelectedModel] = useState('flash'); // Default model\n    const [selectedApiKeyType, setSelectedApiKeyType] = useState('free'); // Default API key type\n\tconst [result, setResult] = useState(null); // Stores the backend response object\n\tconst [isLoading, setIsLoading] = useState(false); // API call in progress\n\tconst [error, setError] = useState(null); // For UI-level errors (e.g., file selection)\n\tconst [fileName, setFileName] = useState(''); // Display selected filename\n\n\t// Fetch available schemas when the component mounts\n\tconst loadSchemas = useCallback(async () => {\n\t\ttry {\n\t\t\tconsole.log(\"Attempting to fetch schemas...\");\n\t\t\tsetIsLoading(true); // Indicate loading schemas\n\t\t\tsetError(null);\n\t\t\tconst schemaList = await fetchSchemas();\n\t\t\tsetSchemas(schemaList || []);\n\t\t\t// Set default selected schema if list is not empty\n\t\t\tif (schemaList && schemaList.length > 0 && !selectedSchema) {\n\t\t\t\tsetSelectedSchema(schemaList[0]); // Default to the first option\n\t\t\t\tconsole.log(\"Schemas loaded:\", schemaList);\n\t\t\t} else if (!schemaList || schemaList.length === 0) {\n\t\t\t\tconsole.warn(\"No schemas received from backend.\");\n                setSelectedSchema(''); // Ensure no schema is selected if none are available\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error(\"Schema loading error:\", err);\n\t\t\tsetError(`Failed to load output schemas: ${err.message}`);\n\t\t\tsetSchemas([]); // Ensure schemas is an array even on error\n            setSelectedSchema('');\n\t\t} finally {\n\t\t\t setIsLoading(false); // Done loading schemas\n\t\t}\n\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, []); // Correct: Empty dependency array runs only once on mount\n\n\tuseEffect(() => {\n\t\tloadSchemas();\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, []); // Correct: Empty dependency array runs only once on mount\n\n\n\t// Handle file selection\n\tconst handleFileChange = (event) => {\n\t\tconst selectedFile = event.target.files[0];\n\t\tif (selectedFile) {\n\t\t\tsetFile(selectedFile);\n\t\t\tsetFileName(selectedFile.name);\n\t\t\tsetError(null); // Clear previous UI errors\n\t\t\tsetResult(null); // Clear previous results\n\t\t\tconsole.log(\"File selected:\", selectedFile.name, selectedFile.type);\n\t\t} else {\n\t\t\tsetFile(null);\n\t\t\tsetFileName('');\n\t\t}\n\t\t// Reset the input value to allow selecting the same file again\n\t\tevent.target.value = null;\n\t};\n\n\t// Handle form submission\n\tconst handleSubmit = async (event) => {\n\t\tevent.preventDefault(); // Prevent default HTML form submission\n\n\t\t// Basic validation\n\t\tif (!file) {\n\t\t\tsetError(\"Please select a document file to process.\");\n\t\t\treturn;\n\t\t}\n\t\tif (!prompt.trim()) {\n\t\t\tsetError(\"Please enter a processing prompt.\");\n\t\t\treturn;\n\t\t}\n\t\tif (schemas.length > 0 && !selectedSchema) {\n            // If schemas are loaded, but none is selected (e.g., after an error/reload)\n            // Optionally default here, or ensure initial state is handled by loadSchemas\n             if (schemas[0]) setSelectedSchema(schemas[0]);\n             else {\n                 setError(\"Please select a valid output schema.\");\n                 return;\n             }\n        }\n\n\t\t// Prepare for API call\n\t\tsetIsLoading(true);\n\t\tsetError(null); // Clear previous UI-level errors\n\t\tsetResult(null); // Clear previous results\n\n\t\t// Create FormData object\n\t\tconst formData = new FormData();\n\t\tformData.append('file', file);\n\t\tformData.append('prompt', prompt);\n\t\tformData.append('schema_name', selectedSchema); // Send selected schema name\n\t\tformData.append('model_type', selectedModel); // Send selected model type\n        formData.append('api_key_type', selectedApiKeyType); // Send selected API key type\n\n\t\tconsole.log(\"Submitting form data...\");\n\n\t\ttry {\n\t\t\t// Call the API service function\n\t\t\tconst response = await processDocument(formData);\n\t\t\tsetResult(response); // Store the entire response object (contains status, data, error_message)\n\t\t\t// Clear UI error if API call succeeds, even if processing failed\n\t\t\tsetError(null);\n\t\t} catch (err) {\n\t\t\t console.error(\"Form submission error:\", err);\n\t\t\t // Display error message caught by the API service\n\t\t\t setError(err.message || \"An unexpected error occurred during submission.\");\n\t\t\t setResult(null); // Ensure no stale results are shown\n\t\t} finally {\n\t\t\tsetIsLoading(false); // End loading state\n\t\t}\n\t};\n\n\treturn (\n\t\t<div className=\"app-container\">\n\t\t\t<h1>AI Document Processor</h1>\n\n\t\t\t{/* Display UI-level errors (file selection, prompt empty, schema load fail) */}\n\t\t\t{error && !isLoading && (\n\t\t\t\t<div className=\"error-message\">{error}</div>\n\t\t\t )}\n\n\t\t\t<form onSubmit={handleSubmit}>\n\t\t\t\t{/* File Upload */}\n\t\t\t\t<div className=\"form-group\">\n\t\t\t\t\t<label htmlFor=\"file-upload\">1. Upload Document</label>\n\t\t\t\t\t<input\n\t\t\t\t\t\tid=\"file-upload\"\n\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\t// Define accepted types for browser filtering (backend validation is key)\n\t\t\t\t\t\taccept=\".pdf,.txt,.md,.json,.jpeg,.jpg,.png,.webp,.gif,.html,.htm\"\n\t\t\t\t\t\tonChange={handleFileChange}\n\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t/>\n\t\t\t\t\t {fileName && <span className=\"file-name-display\">Selected: {fileName}</span>}\n\t\t\t\t</div>\n\n\t\t\t\t{/* Prompt Input */}\n\t\t\t\t<div className=\"form-group\">\n\t\t\t\t\t<label htmlFor=\"prompt\">2. Enter Processing Prompt</label>\n\t\t\t\t\t<textarea\n\t\t\t\t\t\tid=\"prompt\"\n\t\t\t\t\t\tvalue={prompt}\n\t\t\t\t\t\tonChange={(e) => setPrompt(e.target.value)}\n\t\t\t\t\t\tplaceholder=\"e.g., Summarize this document, Extract key entities, Answer questions based on the text...\"\n\t\t\t\t\t\trequired\n\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t\trows={4}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Schema Selector */}\n\t\t\t\t<div className=\"form-group\">\n\t\t\t\t\t<label htmlFor=\"schema-select\">3. Select Output Schema (Optional)</label>\n\t\t\t\t\t<select\n\t\t\t\t\t\tid=\"schema-select\"\n\t\t\t\t\t\tvalue={selectedSchema}\n\t\t\t\t\t\tonChange={(e) => setSelectedSchema(e.target.value)}\n\t\t\t\t\t\tdisabled={isLoading || schemas.length === 0}\n\t\t\t\t\t\trequired // Make selection required if schemas are available\n\t\t\t\t\t>\n\t\t\t\t\t\t<option value=\"\" disabled={schemas.length > 0}>-- Select Schema --</option>\n\t\t\t\t\t\t{/* Handle loading/error state for schemas */}\n\t\t\t\t\t\t{schemas.length === 0 && !isLoading && <option value=\"\" disabled>No Schemas Available</option>}\n\t\t\t\t\t\t{/* Populate with fetched schemas */}                        {schemas.map((schema) => (\n\t\t\t\t\t\t\t<option key={schema} value={schema}>\n\t\t\t\t\t\t\t\t{schema}\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\n                 {/* Model Selector */}\n                 <div className=\"form-group\">\n                    <label>4. Select Model</label>\n                    <div className=\"radio-group\">\n                        <label>\n                            <input\n                                type=\"radio\"\n                                value=\"flash\"\n                                checked={selectedModel === 'flash'}\n                                onChange={(e) => setSelectedModel(e.target.value)}\n                                disabled={isLoading}\n                            /> Flash\n                        </label>\n                        <label>\n                            <input\n                                type=\"radio\"\n                                value=\"pro\"\n                                checked={selectedModel === 'pro'}\n                                onChange={(e) => setSelectedModel(e.target.value)}\n                                disabled={isLoading}\n                            /> Pro\n                        </label>\n                    </div>\n                </div>\n\n                {/* API Key Type Selector */}\n                <div className=\"form-group\">\n                    <label>5. Select API Key Type</label>\n                    <div className=\"radio-group\">\n                        <label>\n                            <input\n                                type=\"radio\"\n                                value=\"free\"\n                                checked={selectedApiKeyType === 'free'}\n                                onChange={(e) => setSelectedApiKeyType(e.target.value)}\n                                disabled={isLoading}\n                            /> Free\n                        </label>\n                        <label>\n                            <input\n                                type=\"radio\"\n                                value=\"paid\"\n                                checked={selectedApiKeyType === 'paid'}\n                                onChange={(e) => setSelectedApiKeyType(e.target.value)}\n                                disabled={isLoading}\n                            /> Paid\n                        </label>\n                    </div>\n                </div>\n\n\t\t\t\t{/* Submit Button */}\n\t\t\t\t<button type=\"submit\" disabled={isLoading || !file || (schemas.length > 0 && !selectedSchema)}>\n\t\t\t\t\t{isLoading ? 'Processing...' : 'Process Document'}\n\t\t\t\t</button>\n\t\t\t</form>\n\n\t\t\t{/* Loading Indicator during API call */}\n\t\t\t{isLoading && schemas.length > 0 && <div className=\"loading-message\">Processing your document, please wait... This may take some time.</div>}\n            {/* Loading indicator for schema loading */}\n\t\t\t{isLoading && schemas.length === 0 && <div className=\"loading-message\">Loading schemas...</div>}\n\n\n\t\t\t{/* Display Results */}\n\t\t\t<OutputDisplay result={result} />\n\n\t\t</div>\n\t);\n}\n\nexport default App;\n"
    },
    {
      "file": "./AI_doc_processor_webapp/backend/requirements.txt",
      "content": "fastapi\nuvicorn[standard]\npython-multipart\npython-dotenv\nrequests\n\n# Dependencies from Knowledge Base project (ensure versions are compatible)\ngoogle-generativeai>=0.5.0 # Or the specific version used\npydantic>=2.0.0\n# Add any other direct dependencies of the Knowledge Base script/utils if needed\n"
    },
    {
      "file": "./AI_doc_processor_webapp/backend/.env",
      "content": "# --- Gemini API Configuration ---\n# Fill these with your actual model names and API keys\n\n# Paid Tier Credentials\nAPI_KEY_PAID=\"YOUR_PAID_API_KEY_HERE\"\nGEMINI_20_PRO=\"YOUR_PAID_PRO_MODEL_NAME_HERE\" # e.g., models/gemini-1.5-pro-latest\n\n# Free Tier Credentials (if applicable, e.g., AI Studio Key)\nAPI_KEY_FREE=\"YOUR_FREE_API_KEY_HERE\"\nGEMINI_20_PRO_EXP=\"YOUR_FREE_PRO_MODEL_NAME_HERE\" # e.g., models/gemini-1.5-pro-preview-0514 or similar\nGEMINI_20_FL=\"YOUR_FLASH_MODEL_NAME_HERE\" # e.g., models/gemini-1.5-flash-latest\n\n# --- System Instructions Paths (Relative to Knowledge Base project root) ---\n# Update these paths if your structure differs\nSYSTEM_INSTRUCTIONS_PATH=\"../Knowledge Base/data/system_instructions_general.txt\"\nSYSTEM_INSTRUCTIONS_STRUCTURED_PATH=\"../Knowledge Base/data/system_instructions_structured.txt\"\n\n# --- Optional: Output paths for the original script (if used directly, less relevant for web app) ---\n# STRUCTURED_OUTPUT_JSON_SCHEMA=\"StructuredListOutput\"\n# OUTPUT_JSON_PATH=\"./output_version.json\"\n\n# --- Webapp Specific Config ---\nLOG_FILE=\"./backend/logs/app.log\"\nLOG_LEVEL=\"INFO\"\n# Add other backend specific configurations if needed\n"
    },
    {
      "file": "./AI_doc_processor_webapp/backend/core_processor.py",
      "content": "import os\nimport sys\nimport logging\nimport pathlib\nimport json\nfrom typing import Optional, Dict, Any, Union, List, Tuple\n\nfrom fastapi import HTTPException\n\n# Add the Knowledge Base source directory to the Python path\nKB_PROJECT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../Knowledge Base'))\nSRC_DIR = os.path.join(KB_PROJECT_DIR, 'src')\nif KB_PROJECT_DIR not in sys.path:\n    sys.path.insert(0, KB_PROJECT_DIR)\nif SRC_DIR not in sys.path:\n    sys.path.insert(0, SRC_DIR)\n\n# Now import from the Knowledge Base project\ntry:\n    from google.genai import types, client, generativeai as genai\n    import google.api_core.exceptions\n    from utils import gemini_utils\n    # Ensure schemas are registered by importing the modules\n    from data import generic_JSON_response_schema # noqa\n    from data import PDF_page_JSON_schema # noqa\nexcept ImportError as e:\n    print(f\"ERROR: Failed to import modules from Knowledge Base project.\", file=sys.stderr)\n    print(f\"Attempted Path: {KB_PROJECT_DIR}\", file=sys.stderr)\n    print(f\"Sys Path: {sys.path}\", file=sys.stderr)\n    print(f\"Import Error: {e}\", file=sys.stderr)\n    # Re-raise or exit if core functionality is missing\n    raise ImportError(\"Could not load necessary modules from Knowledge Base project.\") from e\n\nlogger = logging.getLogger(__name__)\n\nSUPPORTED_TEXT_MIMES = [\n    'text/plain', 'text/markdown', 'text/csv', 'application/json',\n    'text/html', 'application/xml', 'text/x-python', # Add more as needed\n]\nSUPPORTED_IMAGE_MIMES = [\n    'image/jpeg', 'image/png', 'image/webp', 'image/gif'\n]\nSUPPORTED_PDF_MIME = 'application/pdf'\n\ndef _prepare_gemini_part(file_content: bytes, mime_type: str) -> Union[str, types.Part]:\n    \"\"\"Prepares the file content as a string or Part for the Gemini API.\"\"\"\n    if mime_type == SUPPORTED_PDF_MIME:\n        logger.debug(f\"Preparing Part for PDF ({len(file_content)} bytes)\")\n        return types.Part.from_bytes(data=file_content, mime_type=mime_type)\n    elif mime_type in SUPPORTED_IMAGE_MIMES:\n        logger.debug(f\"Preparing Part for image ({mime_type}, {len(file_content)} bytes)\")\n        return types.Part.from_bytes(data=file_content, mime_type=mime_type)\n    elif mime_type in SUPPORTED_TEXT_MIMES or mime_type.startswith('text/'):\n        logger.debug(f\"Preparing text content ({mime_type}, {len(file_content)} bytes)\")\n        try:\n            # Decode assuming UTF-8, replace errors\n            return file_content.decode('utf-8', errors='replace')\n        except Exception as e:\n            logger.error(f\"Failed to decode text content ({mime_type}): {e}\", exc_info=True)\n            raise HTTPException(status_code=400, detail=f\"Could not decode file content as text ({mime_type}).\")\n    else:\n        logger.warning(f\"Unsupported MIME type for direct processing: {mime_type}. Attempting text decode.\")\n        # Fallback attempt for unknown types - treat as text\n        try:\n            return file_content.decode('utf-8', errors='replace')\n        except Exception:\n             raise HTTPException(status_code=415, detail=f\"Unsupported file type: {mime_type}. Cannot process.\")\n\ndef process_single_document(file_content: bytes, mime_type: str, prompt: str,\n                              model_type: str, api_key_type: str, schema_name: Optional[str]) -> Dict[str, Any]:\n    \"\"\"Processes a single document using the Gemini API via refactored utils.\n\n    Args:\n        file_content: The raw bytes content of the uploaded file.\n        mime_type: The MIME type of the uploaded file.\n        prompt: The user-provided processing prompt.\n        model_type: 'pro' or 'flash'.\n        api_key_type: 'free' or 'paid'.\n        schema_name: The name of the Pydantic schema to use for structured output, or None.\n\n    Returns:\n        A dictionary mimicking the frontend's expected 'result' structure.\n    \"\"\"\n    logger.info(f\"Starting processing for file type: {mime_type}, model: {model_type}, key: {api_key_type}, schema: {schema_name}\")\n    result = {\n        \"status\": \"error\",\n        \"raw_output\": None,\n        \"structured_output\": None,\n        \"schema_used\": schema_name if schema_name else \"(No Schema - Plain Text)\",\n        \"usage_metadata\": None,\n        \"error_message\": \"Processing did not complete.\"\n    }\n\n    try:\n        # 1. Configure Gemini Client and Model Name\n        # This reads from environment variables based on model/key type\n        genai_client, model_name = gemini_utils.configure_gemini(model_type, api_key_type)\n\n        # 2. Determine Mode and Resolve Schema\n        is_structured_mode = bool(schema_name)\n        schema_class = None\n        if is_structured_mode:\n            schema_class = gemini_utils.resolve_schema_class(schema_name)\n            if not schema_class:\n                # This case should ideally be caught by frontend validation or defaults\n                raise ValueError(f\"Specified schema '{schema_name}' could not be resolved.\")\n            result[\"schema_used\"] = schema_class.__name__ # Use resolved name\n\n        # 3. Load System Instructions\n        sys_instructions = gemini_utils.load_system_instructions(is_structured_mode)\n\n        # 4. Prepare Generation Configuration\n        gen_config_args = {\"max_output_tokens\": 8192} # Consider making this configurable\n        if sys_instructions:\n             gen_config_args[\"system_instruction\"] = sys_instructions\n\n        if is_structured_mode and schema_class:\n            gen_config_args[\"response_mime_type\"] = \"application/json\"\n            gen_config_args[\"response_schema\"] = schema_class\n        generation_config = types.GenerateContentConfig(**gen_config_args)\n        logger.debug(f\"Generation Config prepared. Structured: {is_structured_mode}\")\n\n        # 5. Prepare Content Parts for Gemini API\n        document_part = _prepare_gemini_part(file_content, mime_type)\n        contents = [document_part, prompt] # Order might matter\n        logger.debug(\"Content parts prepared for API call.\")\n\n        # 6. Call Gemini API (Synchronously)\n        logger.info(f\"Calling Gemini model '{model_name}'...\")\n        response: types.GenerateContentResponse = gemini_utils.generate_gemini_content(\n            genai_client=genai_client,\n            model_name=model_name,\n            contents=contents,\n            generation_config=generation_config,\n            is_structured_mode=is_structured_mode\n        )\n        logger.info(\"Gemini API call successful.\")\n\n        # 7. Process Response\n        result[\"raw_output\"] = response.text\n        if response.usage_metadata:\n            result[\"usage_metadata\"] = {\n                \"prompt_token_count\": response.usage_metadata.prompt_token_count,\n                \"candidates_token_count\": response.usage_metadata.candidates_token_count,\n                \"total_token_count\": response.usage_metadata.total_token_count\n            }\n\n        # Attempt to parse structured output if requested\n        if is_structured_mode:\n            parsed
